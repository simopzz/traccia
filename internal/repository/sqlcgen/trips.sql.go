// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: trips.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEventsByTripAndDateRange = `-- name: CountEventsByTripAndDateRange :one
SELECT COUNT(*)::int AS event_count
FROM events
WHERE trip_id = $1
  AND (event_date < $2 OR event_date > $3)
`

type CountEventsByTripAndDateRangeParams struct {
	TripID      int32
	EventDate   pgtype.Date
	EventDate_2 pgtype.Date
}

func (q *Queries) CountEventsByTripAndDateRange(ctx context.Context, arg CountEventsByTripAndDateRangeParams) (int32, error) {
	row := q.db.QueryRow(ctx, countEventsByTripAndDateRange, arg.TripID, arg.EventDate, arg.EventDate_2)
	var event_count int32
	err := row.Scan(&event_count)
	return event_count, err
}

const createTrip = `-- name: CreateTrip :one
INSERT INTO trips (name, destination, start_date, end_date, user_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, name, destination, start_date, end_date, created_at, updated_at
`

type CreateTripParams struct {
	Name        string
	Destination pgtype.Text
	StartDate   pgtype.Date
	EndDate     pgtype.Date
	UserID      pgtype.UUID
}

func (q *Queries) CreateTrip(ctx context.Context, arg CreateTripParams) (Trip, error) {
	row := q.db.QueryRow(ctx, createTrip,
		arg.Name,
		arg.Destination,
		arg.StartDate,
		arg.EndDate,
		arg.UserID,
	)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Destination,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTrip = `-- name: DeleteTrip :exec
DELETE FROM trips WHERE id = $1
`

func (q *Queries) DeleteTrip(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteTrip, id)
	return err
}

const getTripByID = `-- name: GetTripByID :one
SELECT id, user_id, name, destination, start_date, end_date, created_at, updated_at FROM trips WHERE id = $1
`

func (q *Queries) GetTripByID(ctx context.Context, id int32) (Trip, error) {
	row := q.db.QueryRow(ctx, getTripByID, id)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Destination,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listTrips = `-- name: ListTrips :many
SELECT id, user_id, name, destination, start_date, end_date, created_at, updated_at FROM trips
WHERE (user_id = $1 OR $1 IS NULL)
ORDER BY start_date DESC, created_at DESC
`

func (q *Queries) ListTrips(ctx context.Context, userID pgtype.UUID) ([]Trip, error) {
	rows, err := q.db.Query(ctx, listTrips, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Trip{}
	for rows.Next() {
		var i Trip
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Destination,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTrip = `-- name: UpdateTrip :one
UPDATE trips
SET name = $2, destination = $3, start_date = $4, end_date = $5, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, name, destination, start_date, end_date, created_at, updated_at
`

type UpdateTripParams struct {
	ID          int32
	Name        string
	Destination pgtype.Text
	StartDate   pgtype.Date
	EndDate     pgtype.Date
}

func (q *Queries) UpdateTrip(ctx context.Context, arg UpdateTripParams) (Trip, error) {
	row := q.db.QueryRow(ctx, updateTrip,
		arg.ID,
		arg.Name,
		arg.Destination,
		arg.StartDate,
		arg.EndDate,
	)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Destination,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
